---
layout: post
title:  "Linux2.4安装一个文件系统"
category: [操作系统]
tags: [linux2.6]
---

在一个块设备上按一定的格式建立起文件系统的时候，或者系统引导之初，设备上的文件和节点是不可访问的  
只有把它安装到文件系统中的某个节点上，才能使设备上的文件和节点成为可访问的  
经过安装后，设备上的文件系统就成为整个文件系统的一部分，或者说，一个子系统  
  
最初时，整个文件系统只有一个节点，即根节点"/"，这个节点存在于内存中，而不存在于任何具体的设备上  
系统在初始化时将一个设备安装到节点"/"上，这设备就称为根设备，这个设备上的文件系统称为整个系统中原始的基本的文件系统  
由超级用户进程通过系统调用mount()把其它的子系统安装到已存在于系统中的空闲节点上  
  
UNIX将设备看作一种特殊的文件，并在文件系统中有代表着具体设备的节点称为设备文件  
每个设备文件实际上只是一个索引节点，节点中提供了设备的设备号  
只要找到了代表着某个设备的索引节点，就知道怎样读写这个设备了  
  
安装前可访问的只是这个设备，通常是作为一个线性的无结构的字节流来访问的，而设备上的文件系统是不可访问的  
经过安装后，设备上的文件系统就成为可访问的了。  
  
#### 0.do_mount() -----> 安装一个文件系统的系统调用
（1）若只是改变一个已安装设备的安装方式，则do_remount  
（2）对回接设备的处理do_loopback()：见4  
（3）权限检查  
（4）获得待安装系统的文件系统结构，若找不到，则说明系统不支持该结构  
（5）获得安装点的dentry结构  
利用上一篇文章中的`path_init()`和`path_walk()`  
（6）获取待安装设备的超级块：  
若是虚拟文件系统，则出错返回  
若是正常的文件系统类型，则`get_sb_deb()`：见1  
若是再次安装同一类型的其它设备时，只需要共享已存在的超级块`get_sb_single()`、  
若根本就没有设备，连整个文件系统都是虚拟的，则`get_sb_nodev`  
（7）再次检查，若该安装点已经安装有另一个设备，则将设备安装到其父节点  
循环检查，直到可以安装或到了根节点  
将一个设备安装到一个有内容的目录节点时，节点就变成了一个纯粹的安装点，原来目录中的内容就变成不可访问了  
（8）安装add_vfsmnt()：见3  
把待安装设备的super_block结构与安装点的dentry结构联系到一起，利用连接件vfsmount  

#### 1.`get_sb_deb()` -----> 从内存中获取待安装文件系统的超级块，若没有，就创建一个
（1）获取设备文件的dentry  
利用上一篇文章中的`path_init()`和`path_walk()`  
（2）dentry -> inode  
（3）inode -> dev：设备号  
（4）dev -> sb：根据设备号获得超级块  
先从内存中找（同一设备可以安装多次，这个前面0-（5）中的共享超级块不同）  
若未找到，则创建一个：见2  
返回sb  

#### 2.在内存中分配一个新的超级块
（1）打开待安装的设备  
（2）在内存中申请一个空闲的super_block结构  
（3）初始化新申请的super_block结构  
（4）从（1）中读出超级块的信息，并填入新申请的super_block中  

#### 3.add_vfsmnt()：把待安装设备的super_block结构与安装点的dentry结构联系到一起，利用连接件vfsmount
（1）分配一个vfsmount结构  
（2）为vfsmount结构赋值  
（3）利用指针对vfsmount结构、安装点的dentry结构、设备的dentry结构进行连接，连接后的结果见下一篇博客的图  

#### 4.do_loopback() -----> 对回接设备的处理
1.待补充  
