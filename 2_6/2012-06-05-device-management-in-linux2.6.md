---
layout: post
title:  "Linux2.6块设备驱动程序"
category: [操作系统]
tags: [linux2.6, device]
---

#### 一、设备管理与文件管理的关系
##### 1.文件操作是对设备操作的组织与抽象
设备操作是对文件操作的最终实现
![](http://my.csdn.net/uploads/201206/04/1338815464_4456.gif)

#### 二、设备驱动程序模型
1./sys -----> 总线 -----> PCI -----> 驱动程序 -----> 串口 -----> 设备  
2.设备驱动程序模型中的几个主要的层次：  
（1）总线，见Linux2.6 I/O体系结构  
（2）PCI总线，见三  
（3）驱动程序，见四  
（4）设备，见五  

#### 三、PCI总线
##### 1.地址分配策略
I/O地址空间与内存空间相分离，将I/O寄存器的地址映射成内存地址，通过内存指令来操作这些寄存器

##### 2.总线竞争策略
（1）配备一个分时仲裁器，遇到冲突时，仲裁器选择一个设备暂时成为“主设备”，其余的等待  
（2）提供“写缓冲区”，写操作因为总线冲突不能使用PCI时，把要写的内容放入缓冲区中，托付给PCI  
（3）从设备通过竞争暂时成为主设备，是对DMA的扩展  

##### 3.总线扩展策略
CPU通过“宿主-总线桥”与主PCI相连，可以通过“PCI-PCI桥”或“PCI-ISA桥”把总线扩展成一棵树，外部设备通过主PCI或其它层PCI直接或间接地与CPU相连  
桥也是一种外部设备  
![](http://my.csdn.net/uploads/201206/04/1338815662_5128.gif)

##### 4.访问某个设备的某个寄存器
让所有设备的配置寄存器组都采用相同的地址，由所在总线的PCI桥在访问时附加上其它条件来区分。  
CPU通过一个统一的入口地址向“宿主-PCI桥”发出命令，由相应的PCI桥间接完成具体的读写操作  
要访问某个设备的某个寄存器时，CPU先往地址寄存器中写入目标地址（包括总线号、设备号、功能号以及配置寄存器地址，其中前面三个就是上文中说的附加条件），然后通过数据寄存器读写数据  

#### 四、驱动程序
##### 1.驱动程序
驱动程序实现了VFS提供的函数接口（open，read，lseek等），使得设备响应来自VFS的控制  
要使设备在系统中成为可见，必须（1）在文件系统中有一个代表此设备的文件结点（2）在驱动设备层中有这种设备的驱动程序  
Linux使用“可安装模块module”来实现驱动设备的动态安装  

##### 2.module
module是经过编译但是尚未连接的目标代码（.o文件），主要通过系统调用实现。  
（1）方便：凡是内核或其它已安装模块中可以“移出export”的所有符号，都可以在module中引用  
（2）安全：除了这些符号和系统调用，module不能访问内核中其它资源

##### 3.驱动程序module的安装
（1）将module读入用户空间  
（2）向内核询问“移出export符号”的地址：query_module()  
（3）建立单向链接，使模块中所有符号引用引用都得到落实  
（4）创建module结构，“预订”所需系统空间：create_module()  
（5）把用户空间中完成了单向连接的模块映像装入内核：init_module()
（6）向内核“登记”本模块中的一些包含着函数指针的数据结构init_module()，双向连接完成  
**note：（5）中的init_module()与（6）中的init_module()不同。（5）是系统调用sys_init_module()，在内核中是唯一的；（6）是每个可安装模块中都有的一个函数**

##### 4.sys_init_module()
（1）选择目标module并检查  
（2）把用户空间的module赋值给内核空间的module  
（3）再次验证所依赖项在内核中  
（4）将每个module_ref链入到所依赖项中  
（5）启动执行模块的init_module()  
module没有自己的init_module()也是允许的，但这样模块的存在就没有意义了  

##### 5.块设备驱动程序，见[Linux2.6块设备驱动程序](http://blog.csdn.net/mishifangxiangdefeng/article/details/7641045)

#### 五、设备
1.设备文件是文件系统中代表设备的文件。Linux把I/O设备文件当作特殊文件，通过与普通文件进行交互所用的同一系统调用可直接用于I/O设备
设备文件在**其宿主文件系统所在的设备上**只占一个索引节点，没有存放数据的记录块   
设备文件的存在，不是为了存取数据，只是为应用程序提供一条通向具体设备的访问途径，使应用程序可以与具体设备建立连接  

2.设备文件可分为两类：块设备、字符设备  

3.创建一个设备文件sys_mknod  
（1）获得目标的路径名  
（2）获得目标的父的dentry和vfsmount  
（3）找到或创建目标的dentry  
（4）若待创建的是普通文件，则vfs_create()：见[Linux2.4打开一个文件的系统调用](http://blog.csdn.net/mishifangxiangdefeng/article/details/7585610)  
若待创建的是特殊文件，则vfs_mknod()：见4  
若待创建的是目标文件，则出错  

4.创建设备结点vfs_mknod()，dir->i_op->mk_nod()，ext2_mknod()  
（1）各种检查  
（2）创建一个inode  
（3）初始化inode  
（4）把新创建的inode加进所在目录在磁盘上的目录文件  
（5）inode挂脏队列  
（6）将内存中的dentry和inode挂钩  

#### 六、监控I/O操作
I/O操作的持续时间是不可预知的，因此有必须监控I/O操作什么时候结束  
1.轮询模式：CPU重复检查设备的状态寄存器，直到寄存器的值表明I/O操作已经完成  
2.中断模式：I/O控制器通过IRQ线发出I/O操作结束的信号  
3.DMA：一个辅助的DMA电路用来控制RAM和I/O设备之间的数据传送。DMA一但被激活，就可以自行传送数据，数据传送完成后，DMA发送一个中断请求  
